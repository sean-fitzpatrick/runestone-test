<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2022-06-24T11:24:15-06:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
<script>// Make *any* pre with class 'sagecell-sage' an executable Sage cell
// Their results will be linked, only within language type
sagecell.makeSagecell({inputLocation: 'pre.sagecell-sage',
                       linked: true,
                       languages: ['sage'],
                       evalButtonText: 'Evaluate (Sage)'});
</script>
</head>
<body class="ignore-math"><div class="solution solution-like">
<p>We'll solve this problem with the help of the computer.</p>
<pre class="ptx-sagecell sagecell-sage" id="sage-54"><script type="text/x-sage">from sympy import Matrix,init_printing,factor
init_printing()
A = Matrix(3,3,[5,-2,-4,-2,8,-2,-4,-2,5])
p=A.charpoly().as_expr()
factor(p)
</script></pre>
<p>We get <span class="process-math">\(c_A(x)=x(x-9)^2\text{,}\)</span> so our eigenvalues are <span class="process-math">\(0\)</span> and <span class="process-math">\(9\text{.}\)</span> For <span class="process-math">\(0\)</span> we have <span class="process-math">\(E_0(A) = \nll(A)\text{:}\)</span></p>
<pre class="ptx-sagecell sagecell-sage" id="sage-55"><script type="text/x-sage">A.nullspace()
</script></pre>
<p>For <span class="process-math">\(9\)</span> we have <span class="process-math">\(E_9(A) = \nll(A-9I)\text{.}\)</span></p>
<pre class="ptx-sagecell sagecell-sage" id="sage-56"><script type="text/x-sage">from sympy import eye
B=A-9*eye(3)
B.nullspace()
</script></pre>
<p>The approach above is useful as we're trying to remind ourselves how eigenvalues and eigenvectors are defined and computed. Eventually we might want to be more efficient. Fortunately, there's a command for that.</p>
<pre class="ptx-sagecell sagecell-sage" id="sage-57"><script type="text/x-sage">A.eigenvects()
</script></pre>
<p>Note that the output above lists each eigenvalue, followed by its multiplicity, and then the associated eigenvectors.</p>
<p>This gives us a basis for <span class="process-math">\(\R^3\)</span> consisting of eigenvalues of <span class="process-math">\(A\text{,}\)</span> but we want an orthogonal basis. Note that the eigenvector corresponding to <span class="process-math">\(\lambda = 0\)</span> is orthogonal to both of the eigenvectors corresponding to <span class="process-math">\(\lambda =9\text{.}\)</span> But these eigenvectors are not orthogonal to each other. To get an orthogonal basis for <span class="process-math">\(E_9(A)\text{,}\)</span> we apply the Gram-Schmidt algorithm.</p>
<pre class="ptx-sagecell sagecell-sage" id="sage-58"><script type="text/x-sage">from sympy import GramSchmidt
L=B.nullspace()
GramSchmidt(L)
</script></pre>
<p>This gives us an orthogonal basis of eigenvectors. Scaling to clear fractions, we have</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
\left\{\bbm 2\\1\\2\ebm, \bbm -1\\2\\0\ebm, \bbm -4\\-2\\5\ebm\right\}
\end{equation*}
</div>
<p class="continuation">From here, we need to normalize each vector to get the matrix <span class="process-math">\(P\text{.}\)</span> But we might not like that the last vector has norm <span class="process-math">\(\sqrt{45}\text{.}\)</span> One option to consider is to apply Gram-Schmidt with the vectors in the other order.</p>
<pre class="ptx-sagecell sagecell-sage" id="sage-59"><script type="text/x-sage">L=[Matrix(3,1,[-1,0,1]),Matrix(3,1,[-1,2,0])]
GramSchmidt(L)
</script></pre>
<p>That gives us the (slightly nicer) basis</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
\left\{\bbm 2\\1\\2\ebm, \bbm -1\\0\\1\ebm, \bbm 1\\-4\\1\ebm\right\}\text{.}
\end{equation*}
</div>
<p class="continuation">The corresponding orthonormal basis is</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
B = \left\{\frac{1}{3}\bbm 2\\1\\2\ebm, \frac{1}{\sqrt{2}}\bbm -1\\0\\1\ebm, \frac{1}{\sqrt{18}}\bbm 1\\-4\\1\ebm\right\}\text{.}
\end{equation*}
</div>
<p class="continuation">This gives us the matrix <span class="process-math">\(P=\bbm 2/3\amp -1/\sqrt{2}\amp 1/\sqrt{18}\\1/3\amp 0 \amp -4/\sqrt{18}\\2/3\amp 1/\sqrt{2}\amp 1/\sqrt{18}\ebm\text{.}\)</span> Let's confirm that <span class="process-math">\(P\)</span> is orthogonal.</p>
<pre class="ptx-sagecell sagecell-sage" id="sage-60"><script type="text/x-sage">P=Matrix(3,3,[2/3, -1/sqrt(2),1/sqrt(18), 1/3,0,-4/sqrt(18),2/3,1/sqrt(2),1/sqrt(18)])
P,P*P.transpose()
</script></pre>
<p>Since <span class="process-math">\(PP^T=I_3\text{,}\)</span> we can conclude that <span class="process-math">\(P^T=P^{-1}\text{,}\)</span> so <span class="process-math">\(P\)</span> is orthogonal, as required. Finally, we diagonalize <span class="process-math">\(A\text{.}\)</span></p>
<pre class="ptx-sagecell sagecell-sage" id="sage-61"><script type="text/x-sage">Q=P.transpose()
Q*A*P
</script></pre>
<p>Incidentally, the SymPy library for Python does have a diagaonalization routine; however, it does not do orthogonal diagonalization by default. Here is what it provides for our matrix <span class="process-math">\(A\text{.}\)</span></p>
<pre class="ptx-sagecell sagecell-sage" id="sage-62"><script type="text/x-sage">A.diagonalize()
</script></pre>
</div></body>
</html>
