<!DOCTYPE html>
<html lang="en-US">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*       on 2022-06-24T11:24:11-06:00       *-->
<!--*   A recent stable commit (2020-08-09):   *-->
<!--* 98f21740783f166a773df4dc83cab5293ab63a4a *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="example example-like"><h3 class="heading">
<span class="type">Example</span><span class="space"> </span><span class="codenumber">1.1.3</span><span class="period">.</span>
</h3>
<p>The following are examples of vector spaces. We leave verification of axioms as an exercise. (Verification will follow a process very similar to the discussion at the beginning of this section.)</p>
<ol class="decimal">
<li>
<p>The set <span class="process-math">\(\R^n\)</span> of <span class="process-math">\(n\)</span>-tuples <span class="process-math">\((x_1,x_2,\ldots, x_n)\)</span> of real numbers, where we define</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{align*}
(x_1,x_2,\ldots, x_n)+(y_1,y_2,\ldots, y_n) \amp = (x_1+y_1,x_2+y_2,\ldots, x_n+y_n) \\
c(x_1,x_2,\ldots, x_n)\amp = (cx_1,cx_2,\ldots, cx_n)\text{.}
\end{align*}
</div>
<p class="continuation">We will also often use <span class="process-math">\(\R^n\)</span> to refer to the vector space of <span class="process-math">\(1\times n\)</span> column matrices <span class="process-math">\(\bbm x_1\\x_2\\\vdots\\x_n\ebm\text{,}\)</span> where addition and scalar multiplication are defined as for matrices (and the same as the above, with the only difference being the way in which we choose to write our vectors). If the distinction between <span class="process-math">\(n\)</span>-tuples and column matrices is ever important, it will be made clear.</p>
</li>
<li><p>The set <span class="process-math">\(M_{mn}(\R)\)</span> of <span class="process-math">\(m\times n\)</span> matrices, equipped with the usual matrix addition and scalar multiplication.</p></li>
<li>
<p>The set <span class="process-math">\(P_n(\R)\)</span> of all polynomials</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
p(x) = a_0+a_1x+\cdots + a_nx^n
\end{equation*}
</div>
<p class="continuation">of degree less than or equal to <span class="process-math">\(n\text{,}\)</span> where, for</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{align*}
p(x) \amp = a_0+a_1x+\cdots + a_nx^n \\
q(x) \amp = b_0+b_1x+\cdots +b_nx^n
\end{align*}
</div>
<p class="continuation">we define</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
p(x)+q(x)=(a_0+b_0)+(a_1+b_1)x+\cdots + (a_n+b_n)x^n
\end{equation*}
</div>
<p class="continuation">and</p>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
cp(x) = ca_0+(ca_1)x+\cdots + (ca_n)x^n\text{.}
\end{equation*}
</div>
<p class="continuation">The zero vector is the polynomial <span class="process-math">\(0=0+0x+\cdots + 0x^n\text{.}\)</span></p>
<p>This is the same as the addition and scalar multiplication we get for functions in general, using the “pointwise evaluation” definition: for polynomials <span class="process-math">\(p\)</span> and <span class="process-math">\(q\)</span> and a scalar <span class="process-math">\(c\text{,}\)</span> we have <span class="process-math">\((p+q)(x)=p(x)+q(x)\)</span> and <span class="process-math">\((cp)(x)=c\cdot p(x)\text{.}\)</span></p>
<p>Notice that although this feels like a very different example, the vector space <span class="process-math">\(P_n(\R)\)</span> is in fact very similar to <span class="process-math">\(\R^n\)</span> (or rather, <span class="process-math">\(\R^{n+1}\text{,}\)</span> to be precise). If we associate the polynomial <span class="process-math">\(a_0+a_1x+\cdots + a_nx^n\)</span> with the vector <span class="process-math">\(\langle a_0,a_1,\ldots, a_n\rangle\text{,}\)</span> the addition and scalar multiplication for either space behaves in exactly the same way. We will make this observation precise in <a href="sec-isomorphism.html" class="internal" title="Section 2.3: Isomorphisms, composition, and inverses">Section 2.3</a>.</p>
</li>
<li><p>The set <span class="process-math">\(P(\R)\)</span> of all polynomials of <em class="emphasis">any</em> degree. The algebra works the same as it does in <span class="process-math">\(P_n(\R)\text{,}\)</span> but there is an important difference: in both <span class="process-math">\(P_n(\R)\)</span> and <span class="process-math">\(\R^n\text{,}\)</span> every element in the set can be generated by setting values for a finite collection of coefficients. (In <span class="process-math">\(P_n(\R)\text{,}\)</span> every polynomial <span class="process-math">\(a_0+a_1x+\cdots =a_nx^n\)</span> can be obtained by choosing values for the <span class="process-math">\(n+1\)</span> coefficients <span class="process-math">\(a_0,a_1\ldots, a_n\text{.}\)</span>) But if we remove the restriction on the degree of our polynomials, there is then no limit on the number of coefficients we might need. (Even if any <em class="emphasis">individual</em> polynomial has a finite number of coefficients!)</p></li>
<li>
<p>The set <span class="process-math">\(F[a,b]\)</span> of all functions <span class="process-math">\(f:[a,b]\to \R\text{,}\)</span> where we define <span class="process-math">\((f+g)(x)=f(x)+g(x)\)</span> and <span class="process-math">\((cf)(x)=c(f(x))\text{.}\)</span> The zero function is the function satisfying <span class="process-math">\(0(x)=0\)</span> for all <span class="process-math">\(x\in [a,b]\text{,}\)</span> and the negative of a function <span class="process-math">\(f\)</span> is given by <span class="process-math">\((-f)(x)=-f(x)\)</span> for all <span class="process-math">\(x\in [a,b]\text{.}\)</span></p>
<p>Note that while the vector space <span class="process-math">\(P(\R)\)</span> has an infinite nature that <span class="process-math">\(P_n(\R)\)</span> does not, the vector space <span class="process-math">\(F[a,b]\)</span> is somehow <em class="emphasis">more</em> infinite! Using the language of <a href="sec-dimension.html" class="internal" title="Section 1.7: Basis and dimension">Section 1.7</a>, we can say that <span class="process-math">\(P_n(\R)\)</span> is <dfn class="terminology">finite dimensional</dfn>, while <span class="process-math">\(P(\R)\)</span> and <span class="process-math">\(F[a,b]\)</span> are <dfn class="terminology">infinite dimensional</dfn>. In a more advanced course, one might make a further distinction: the dimension of <span class="process-math">\(P(\R)\)</span> is countably infinite, while the dimension of <span class="process-math">\(F[a,b]\)</span> is <dfn class="terminology">uncountable</dfn>.</p>
</li>
</ol></article><span class="incontext"><a href="sec-vec-sp.html#ex-vector-spaces" class="internal">in-context</a></span>
</body>
</html>
